The goal of this library is to provide a way to describe and compute with Term Rewriting Systems (TRS).

TRSs are a simple formalism from theoretical computer science used to model the evolution of tree-based structures like natural langauge parse trees or abstract syntax trees.

A TRS is defined in two parts. The first is a set, $S$, of symbols. $S$ is called the signature and together with a disjoint set of variables, defines the set of all possible trees, or terms, which the system can consider. The second is a set, $R$, of rewrite rules. A rewrite rule is an equation, $s = t$, and is interpreted as follows: any term matching the pattern described by $s$ can be rewritten according to the pattern described by $t$. Together $S$ and $R$ define a TRS that describes a system of computation, a sort of programming language. TeRF provides a way to describe arbitrary TRSs.

* Further Reading

- Baader & Nipkow (1999). [[http://www.cambridge.org/us/academic/subjects/computer-science/programming-languages-and-applied-logic/term-rewriting-and-all?format=PB&isbn=9780521779203][Term rewriting and all that]]. Cambridge University Press.
- Bezem, Klop, & de Vrijer (Eds.) (2003). [[http://www.cambridge.org/us/academic/subjects/computer-science/programming-languages-and-applied-logic/term-rewriting-systems?format=HB&isbn=9780521391153][Term Rewriting Systems]]. Cambridge University Press.
- [[https://en.wikipedia.org/wiki/Rewriting][Rewriting]]. (2017). Wikipedia.

* Features/TODO
** DONE provide an initial implementation of TRSs
:LOGBOOK:
- State "DONE"       from "DOING"      [2017-04-12 Wed 10:53]
- Note taken on [2017-04-10 Mon 09:19] \\
  I took a bit more time to look at [[https://github.com/mathics/Mathics/][Mathics]] this morning. It is an attempt to implement the [[http://www.wolfram.com/language/][Wolfram Language]] in Python. At the core of it is an already established syntax for writing TRSs. It's got significantly more developmental momentum than anything I might try to build for now. The two questions I need to answer, though, are what work would I need to do if I adopted Mathics, and what would I need to do if I built everything myself?
  
  If I adopt Mathics:
  1. I need to figure out how to strip its power down. That is, I don't think I would initially want the full power of strings and numbers. I would just want the symbols. This would probably be pretty tricky, as the language is built around the availability of both strings and numbers.
  2. I need to figure out how to represent Mathics statements as a TRS, as a collection of rules and symbols. This is probably being done somewhere in the system as the environment is formed and updated, but I'd need to find a way to get access to that environment.
  3. I already have a great deal of the primitive knowledge I might want, though it may not be implemented in the way I might want it implemented
  
  
  If I build everything myself:
  1. I need to implement unification
  2. I need to implement substitution
  3. I need to decide on the syntax I'll use
  4. I have more control
  5. I need to implement all the background kowledge I want to use
- State "DOING"      from "TODO"       [2017-04-10 Mon 09:19]
:END:
I'll build up to a full TRS iteratively as follows:
- add signatures
- add variable terms
- add application terms
- add rewrite rules

I can't do any sort of computation without first having data structures over which to compute. So, each iteration will first extend the parser and will then extend the evaluator.

*** DONE handle whitespace & comments
:LOGBOOK:
- State "DONE"       from "DOING"      [2017-04-06 Thu 14:04] \\
  I'm getting my feet wet and figuring out how to do this sort of work in Python, so this was a good place to start.
- State "DOING"      from "TODO"       [2017-04-06 Thu 13:30] \\
  I'll just do this first to get the basic structure set
:END:
*** DONE add signatures
:LOGBOOK:
- State "DONE"       from "DOING"      [2017-04-07 Fri 11:44]
- State "DOING"      from "TODO"       [2017-04-07 Fri 09:37]
:END:
**** DONE lex the tokens for signatures: "signature" and symbols
:LOGBOOK:
- State "DONE"       from "TODO"       [2017-04-07 Fri 09:39] \\
  This was simple to achieve, and something I did yesterday.
:END:
**** DONE perform a dumb-parse of the signature
:LOGBOOK:
- Note taken on [2017-04-07 Fri 09:52] \\
  Also, I just realized that while long-term, I'd like to be able to pick apart operators and variables syntactically, we can't do that yet because we can't represent terms. But, we can also get rid of the "signature" keyword. We can instead focus on just picking out individual symbols and adding them to the signature. This will require, however, that I figure out how to separate operators from variables syntactically. I can do that in one of two ways. I can introduce a keyword like "signature", which I would prefer not to do, as it requires the clunky idiom of declaring a symbol before using it. This may be premature optimization, though, so let's stick with the simple thing of just declaring operators explicitly.
- State "DONE"       from "TODO"       [2017-04-07 Fri 09:39] \\
  This was also simple to achieve. I'm now able to collect something that looks like the following:
  
  [('signature', ['<sym1>', '<sym2>',..., '<symN>'])]
  
  This is nice; it allows me to create the signature across multiple lines. That is, I could create something like the following:
  
  [('signature', ['<sym1>', '<sym2>',..., '<symM>']),
   ('signature', ['<symM+1>', '<symM+2>',..., '<symM+N>'])]
  
  What I ultimately want to produce, however, isn't a list of multiple signatures, but a single TRS. So, I need to find a way to insert take the knowledge, as I collect it, and transform it into a TRS. Right now, my TRS should only have the signature. So, the goal here is to produce a single signature as the result.
:END:
**** DONE improve the dumb-parse to create a Signature object
:LOGBOOK:
- State "DONE"       from "TODO"       [2017-04-07 Fri 11:44]
:END:
*** DONE add variable & constant terms
:LOGBOOK:
- State "DONE"       from "TODO"       [2017-04-07 Fri 14:15]
:END:
**** DONE lex variables and constant terms
:LOGBOOK:
- State "DONE"       from "TODO"       [2017-04-07 Fri 13:12] \\
  This was simple to do. Variables and constants are just symbols. All I needed to add were a few brackets in case cosntant terms were treated as operators applied to nothing.
:END:
**** DONE parse variables and constant terms
:LOGBOOK:
- State "DONE"       from "TODO"       [2017-04-07 Fri 13:13] \\
  The entire parse has to be done in stages. That is, we can determine the rough role of each line (e.g. add to the signature, add a rewrite rule, give a term to evaluate), but we can't determine its precise role until considering the rest of the program space. That is, we have to to build up the program incrementally. ~load_source~ should probably do that work rather than the parser iself.
:END:
*** DONE add application terms
:LOGBOOK:
- State "DONE"       from "TODO"       [2017-04-07 Fri 14:34]
:END:
**** DONE no new lexer rules are needed
:LOGBOOK:
- State "DONE"       from "TODO"       [2017-04-07 Fri 14:32] \\
  Yay!
:END:
**** DONE add parser rules
:LOGBOOK:
- State "DONE"       from "TODO"       [2017-04-07 Fri 14:32] \\
  These were pretty straightforward, though who knows if the parser is really any good. What's going to be more interesting is step immediately following parsing, where we start building the TRS and then evaluating it.
:END:
*** DONE add rewrite rules
:LOGBOOK:
- State "DONE"       from "TODO"       [2017-04-07 Fri 14:47] \\
  This was again pretty simple. It took me a while to get rolling today, but now that I'm going, I'm making good progress.
:END:
*** DONE create the TRS from the list of Operators and rules
:LOGBOOK:
- State "DONE"       from "TODO"       [2017-04-12 Wed 10:53]
:END:
*** DONE add substitution and evaluation
:LOGBOOK:
- State "DONE"       from "TODO"       [2017-04-12 Wed 10:53]
:END:
** DONE write a REPL?
:LOGBOOK:
- State "DONE"       from "TODO"       [2017-04-13 Thu 15:19] \\
  It only took a couple hours to implement something simple.
- Note taken on [2017-04-13 Thu 12:01] \\
  The sorts of evaluation you'd do in a REPL are different from what you might do in batch mode. In batch mode, you'd want to eat up all the operators, then all the rules, and finally the terms themselves. In REPL mode, you want to eat up each statement one at a time and modify your environment/TRS accordingly.
:END:
** CANCELLED extend TRSs with a list-based description of terms
:LOGBOOK:
- State "CANCELLED"  from "TODO"       [2017-04-19 Wed 08:39] \\
  The original motivation here was to make it easier to write statements like "S x_ y_ z_" and have them interpreted as "(((S x_) y_) z_)". Adding the default "." operator makes this particular extension unnecessary. So, by tweaking the parser a bit, I found a way to avoid an arduous theoretical extension and stick with the basic TRS formalism.
- Note taken on [2017-04-13 Thu 15:58] \\
  One way I could do something like this is to assume a hidden operator "." which binds items together into trees unless told to do something otherwise.
- State "TODO"       from "DOING"      [2017-04-13 Thu 12:48]
- State "DOING"      from "TODO"       [2017-04-13 Thu 12:20]
:END:
What's the basic idea here? The basic idea is that terms in a traditional TRS can come in two forms: variables and applications of operators to subterms. I'm suggesting that terms now come in three forms: variables, symbols, and lists. Variables remain the same and represent any possible term. Symbols are simple units with no meaning. Lists are sequences of variables and symbols. Is this just lisp with pattern matching? Perhaps. Everything is now structured explicitly according to its tree, but we have more flexible matching and rewriting than in lisp. So, what is a term on this view? A term is just a tree of symbols and variables. What is a term on the other view? A term is an application of an operator.

Formally, what's going on here? I am suggesting a subclass of TRSs. I'm saying that all terms which are not symbols or variables are in fact cons pairs. That is, there is only one binary operator: cons. It becomes easy to program in this system because we have a uniform structure for just about everything. Perhaps this is similar to Jay's Pattern Calculus?
** CANCELLED add an assume statement
:LOGBOOK:
- State "CANCELLED"  from "TODO"       [2017-04-19 Wed 08:41] \\
  This became unnecessary when we decided to interpret whitespace as the repeated application of the binary '.' operator.
- Note taken on [2017-04-13 Thu 15:26] \\
  the idea here would be to add a statement that would allow you to assert some initial assumption about how to interpret white space. In functional programming languages, whitespace is treated as function application, for example.
:END:
** DONE add a README
:LOGBOOK:
- State "DONE"       from "TODO"       [2017-04-19 Wed 08:59] \\
  This is the README!
:END:
** DOING improve the legibility of the language
:LOGBOOK:
- State "DOING"      from "TODO"       [2017-04-19 Wed 08:41]
- Note taken on [2017-04-13 Thu 08:08] \\
  Currently, I have to write Peano addition as follows:
  
  +[0 y_] -> y_
  +[ s[x_] y_ ] -> s[ +[x_ y_] ]
  
  And, I have to write SK logic as follows:
  
  .[.[.[S x_] y_] z_] -> .[.[x_ z_] .[y_ z_]]
  .[.[K x_] y_] -> x_
  
  It would be nice to write these as:
  
  0+y = y
  (s x) + y = s (x+y)
  
  or:
  
  0+y = y
  !x! + y = !x+y!
  
  or even:
  
  0+y = y
  x'+y = (x+y)'
  
  and:
  
  S x y z = x z (y z)
  K x y = x
  
  What do I need to be able to do that?
  
  1. I need operators of various fixity (infix, prefix, postfix, outfix, nonfix). ~+~ is written above as an infix operator, ~! !~ as outfix operators, ~0~ as a nonfix operator, ~'~ as a postfix operator, and ~s~, ~S~, and ~K~ as prefix operators.
  
  2. I need parentheses to be able to explicitly group operations. I actually don't need these until I add the various *fix operators. Before I add them, the tree structure is explicit. If I forced the declaration of every operator, would I still need them? I do if I want partial application.
  
  3. I need to convert everything to a curried operation. This is perhaps the most controversial change to me for two reasons. First, it now becomes impossible to declare a function of arity 3. All operators are arity 0 or arity 1, except one privileged operator of arity 2: application. The odd thing to me there is that I can imagine scenarios in which this forces me to add an operator I don't actually need. Look at my original definition of Peano addition above. There is no application operator there. I just use ~+~ and ~s~ directly. I could model that system as:
  
     .[.[+ 0] y_] = y
     .[.[+ .[s x_]] y] = .[s.[.[+ x_] y_]]
  
     but that is cumbersome. It would be nice to be able to separate cases with application from those without using something like the following:
  
     # with application
     x_ y_ : .[x_ y_]
     + 0 y = y
     + (s x) y = s (+ x y)
  
     # without application
     0 + y = y
     x' + y = (x+y)'
  
     # without application 2
     +[0 y_] = y_
     +[s[x_] y_] = s[ +[x_ y_]]
  
     What's going on here? In the "with application" case, I defined a macro. What I wanted in my head was to define a rule which would apply to terms in the rules as well as to terms I would apply. It would become part of the interpreter for terms. So, if I want to add the ability to make application implicit, I need to alter the interpreter by adding macros. That would work how? It would work by adding a meta-TRS which applies to terms before being interpreted by the object TRS. How do I differentiate object-rules and meta-rules? Let's do it with a colon.
  
     In that case, SK logic becomes:
     x_ y_ : .[x_ y_]
     S x_ y_ z_ = x_ z_ (y_ z_)
     K x_ y_ = x_
  
  4. I need to allow function application via juxtaposition rather than via explicit application. See the solution I worked out just above in 3. I can do it via a macro in the cases where I want to use it.
  
  5. Do I want to rearrange how I represent terms?
  
     Hmm... An odd idea here. What if I said that I didn't need to interpret ~+ 0 y~ as a single term but as a list of terms? That is, ~+ 0 y~ would be viewed internally as ~[+ 0 y]~, ~+ (s x) y~ as ~[+ [s x] y]~ and so on. In this case, there's no content in the root to the tree. Instead, the root is just what relates the branches to one another.
  
     In that case, I have these kinds of terms:
     - variables
     - applications
     - lists
  
     I don't know about this idea. It seems interesting, but also dangerous. It's something that doesn't match the definition of TRSs that everyone else uses.
  
  6. I need to change how variables are designated.
  
  7. I need to alter parsing so that operators can touch one another.
:END:
*** DONE add a default operator
:LOGBOOK:
- State "DONE"       from "TODO"       [2017-04-19 Wed 08:35] \\
  Spaces between terms are interpreted as the application of a default binary operator '.'.
:END:
*** DONE add parentheses
:LOGBOOK:
- State "DONE"       from "TODO"       [2017-04-19 Wed 08:36] \\
  We now have parentheses to mark subterms.
:END:
*** DONE add function application via juxtaposition (function = head rule)
:LOGBOOK:
- State "DONE"       from "TODO"       [2017-04-19 Wed 08:37] \\
  This can be achieved by using the default operator to represent application. The default operator can be used to represent any binary operator, however. It isn't required to be application. It also doesn't need to be used at all. You could be completely explicit about the operators you use. Function application just happens to be pretty common.
:END:
*** TODO add fixity operators
**** TODO add infix operators
**** TODO add postfix operators
**** TODO add outfix operators
**** TODO add nonfix operators
**** TODO add prefix operators
*** TODO allow operators to touch
*** TODO improve variable designation?
** TODO add "macros"
:LOGBOOK:
- Note taken on [2017-04-13 Thu 12:07] \\
  These aren't macros per se, but a change to the evaluation system such that rules are interpreted according to existing rules as they are added to the system. One difficulty here is that order becomes important in determining the behavior of the system, but that's okay for now.
- Note taken on [2017-04-13 Thu 12:05] \\
  You could use this approach, for example, to allow function application via juxtaposition. See my notebook from around the time of this comment for a good example.
:END:
** TODO add conditionals
** TODO extend to graphs as opposed to terms
** TODO add non-deterministic evaluation
** TODO add this example somewhere in the README
I like the example of ~map~ given in the answer.
http://stackoverflow.com/questions/24330902/
** TODO evaluate rules as they are added to the TRS
:LOGBOOK:
- Note taken on [2017-04-27 Thu 12:59] \\
  Add something like the following when adding a rule:
  
  ~newRule = RewriteRule(self.eval(rule.lhs), self.eval(rule.rhs))~
:END:
** TODO proposer ideas
- move rule proposer, move a rule to a new position in the rule set
- add variable
- remove variable
